import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, date, timedelta
import io
from scipy import stats
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Aquicultura Analytics Pro",
    page_icon="üêü",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS Avan√ßado com √çcone Flutuante
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1e3a8a;
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .metric-card {
        background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
        padding: 1.5rem;
        border-radius: 15px;
        color: white;
        box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        border: 1px solid rgba(255,255,255,0.1);
    }
    .alert-card {
        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        padding: 1.2rem;
        border-radius: 10px;
        color: white;
        margin: 0.8rem 0;
        box-shadow: 0 8px 20px rgba(239,68,68,0.3);
    }
    .success-card {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        padding: 1.2rem;
        border-radius: 10px;
        color: white;
        margin: 0.8rem 0;
        box-shadow: 0 8px 20px rgba(16,185,129,0.3);
    }
    .filter-section {
        background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        padding: 1.5rem;
        border-radius: 12px;
        margin-bottom: 1.5rem;
        border: 1px solid #cbd5e1;
    }
    .stat-card {
        background: white;
        padding: 1.2rem;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        border-left: 4px solid #3b82f6;
    }
    .analysis-section {
        background: #fafafa;
        padding: 2rem;
        border-radius: 15px;
        margin: 1rem 0;
        border: 1px solid #e5e7eb;
    }

    /* √çcone flutuante do Prof. Tilap-IA */
    .floating-professor {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .floating-professor:hover {
        transform: scale(1.1);
        filter: brightness(1.1);
    }

    .professor-container {
        position: relative;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .professor-avatar {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        border: 3px solid white;
        font-size: 24px;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0% { box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); }
        50% { box-shadow: 0 4px 25px rgba(59, 130, 246, 0.8); }
        100% { box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); }
    }

    .speech-bubble {
        background: white;
        border-radius: 15px;
        padding: 8px 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        border: 2px solid #3b82f6;
        font-size: 12px;
        font-weight: 600;
        color: #1e40af;
        white-space: nowrap;
        position: relative;
        animation: bounce 3s infinite;
        max-width: 180px;
        text-align: center;
        line-height: 1.2;
    }

    .speech-bubble::after {
        content: '';
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 8px solid #3b82f6;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
    }

    .speech-bubble::before {
        content: '';
        position: absolute;
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 6px solid white;
        border-top: 4px solid transparent;
        border-bottom: 4px solid transparent;
    }

    @keyframes bounce {
        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
        40% { transform: translateY(-5px); }
        60% { transform: translateY(-3px); }
    }

    /* Responsividade */
    @media (max-width: 768px) {
        .floating-professor {
            bottom: 15px;
            right: 15px;
        }

        .professor-avatar {
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .speech-bubble {
            font-size: 11px;
            padding: 6px 10px;
            max-width: 150px;
        }
    }

    /* Efeito hover no bal√£o */
    .professor-container:hover .speech-bubble {
        background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
        color: white;
        transform: scale(1.05);
    }

    .professor-container:hover .speech-bubble::after {
        border-left-color: #1e40af;
    }

    .professor-container:hover .speech-bubble::before {
        border-left-color: #1e40af;
    }
</style>
""", unsafe_allow_html=True)

# URLs das planilhas
SHEETS_URLS = {
    'tilapias': 'https://docs.google.com/spreadsheets/d/1zoO2Eq-h2mx4i6p6i6bUhGCEXtVWXEZGSRYjnDa13dA/export?format=csv',
    'racao': 'https://docs.google.com/spreadsheets/d/1i-QwgMjC9ZgWymtS_0h0amlAsu9Vu8JvEGpSzTUs_WE/export?format=csv'
}


@st.cache_data(ttl=300, show_spinner=False)
def load_sheets():
    """Carrega planilhas do Google Sheets"""
    data = {}
    errors = {}

    for name, url in SHEETS_URLS.items():
        try:
            df = pd.read_csv(url)
            df = df.dropna(how='all').dropna(axis=1, how='all')

            if len(df) == 0:
                errors[name] = "Planilha vazia ou sem dados v√°lidos"
            else:
                data[name] = df

        except Exception as e:
            errors[name] = f"Erro ao carregar dados: {str(e)}"

    return data, errors


def add_consultor_icon():
    """Vers√£o Base64 com imagem clic√°vel, bot√£o alinhado e texto centralizado - CORRIGIDA"""

    import base64
    import os

    def get_image_base64(image_path):
        """Converte imagem para base64"""
        try:
            if os.path.exists(image_path):
                with open(image_path, "rb") as img_file:
                    return base64.b64encode(img_file.read()).decode()
            return None
        except Exception as e:
            st.error(f"Erro ao processar imagem: {e}")
            return None

    # CSS para alinhamento perfeito COM LINK NA IMAGEM E TEXTO CENTRALIZADO
    st.markdown("""
    <style>
    .professor-container-aligned {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        margin: 2rem auto;
        width: 100%;
        max-width: 300px;
    }

    .professor-image-link {
        text-decoration: none;
        display: block;
        transition: all 0.3s ease;
    }

    .professor-image-aligned {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        border: 4px solid white;
        animation: pulse-aligned 3s ease-in-out infinite;
        position: relative;
        overflow: hidden;
        padding: 5px;
        margin: 0 auto 1.5rem auto;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .professor-image-aligned img {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        object-fit: cover;
        transition: all 0.3s ease;
    }

    .professor-image-aligned .emoji-fallback-aligned {
        font-size: 2.5rem;
        color: white;
    }

    .professor-image-link:hover .professor-image-aligned {
        transform: scale(1.1);
        box-shadow: 0 15px 40px rgba(59, 130, 246, 0.7);
    }

    .professor-image-link:hover .professor-image-aligned img {
        transform: scale(1.05);
        filter: brightness(1.15);
    }

    .professor-image-link:active .professor-image-aligned {
        transform: scale(0.95);
    }

    .professor-container-aligned .stLinkButton {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin: 0;
    }

    .professor-container-aligned .stLinkButton > div {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    .professor-container-aligned .stLinkButton button {
        background: linear-gradient(135deg, #059669 0%, #047857 100%) !important;
        color: white !important;
        border: none !important;
        border-radius: 12px !important;
        padding: 0.75rem 1.5rem !important;
        font-weight: 600 !important;
        font-size: 0.95rem !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3) !important;
        width: auto !important;
        min-width: 180px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        gap: 0.5rem !important;
    }

    .professor-container-aligned .stLinkButton button:hover {
        background: linear-gradient(135deg, #047857 0%, #065f46 100%) !important;
        transform: translateY(-2px) !important;
        box-shadow: 0 6px 20px rgba(5, 150, 105, 0.4) !important;
    }

    .professor-container-aligned .stLinkButton button:active {
        transform: translateY(0px) !important;
    }

    .professor-text-center {
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        width: 100%;
        margin: 1rem auto;
    }

    .professor-text-center p {
        color: #1e40af;
        font-size: 1rem;
        font-weight: 600;
        margin: 0;
        text-align: center;
        line-height: 1.4;
        max-width: 280px;
        word-wrap: break-word;
    }

    @keyframes pulse-aligned {
        0%, 100% { 
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }
        50% { 
            box-shadow: 0 12px 30px rgba(59, 130, 246, 0.6);
        }
    }

    @media (max-width: 768px) {
        .professor-container-aligned {
            max-width: 250px;
        }

        .professor-image-aligned {
            width: 70px;
            height: 70px;
        }

        .professor-image-aligned .emoji-fallback-aligned {
            font-size: 2rem;
        }

        .professor-container-aligned .stLinkButton button {
            font-size: 0.9rem !important;
            padding: 0.65rem 1.2rem !important;
            min-width: 160px !important;
        }

        .professor-text-center p {
            font-size: 0.9rem;
            max-width: 220px;
        }
    }
    </style>
    """, unsafe_allow_html=True)

    # Tentar carregar a imagem
    image_path = "images/Tilap-IA.png"
    img_base64 = get_image_base64(image_path)

    # Centralizar todo o container
    col1, col2, col3 = st.columns([1, 1, 1])

    with col2:
        # Container principal
        st.markdown('<div class="professor-container-aligned">', unsafe_allow_html=True)

        # Imagem clic√°vel com link - HTML SIMPLIFICADO
        if img_base64:
            # HTML em uma linha √∫nica para evitar problemas
            html_image = f'<a href="https://ffastia-bia-rag-bia-chain-mem-vgkrw6.streamlit.app/"  rel="noopener noreferrer" class="professor-image-link" title="Clique para acessar o Prof. Tilap-IA"><div class="professor-image-aligned"><img src="data:image/png;base64,{img_base64}" alt="Prof. Tilap-IA" /></div></a>'
            st.markdown(html_image, unsafe_allow_html=True)
        else:
            # Fallback com emoji - HTML simplificado
            html_fallback = '<a href="https://ffastia-bia-rag-bia-chain-mem-vgkrw6.streamlit.app/"  rel="noopener noreferrer" class="professor-image-link" title="Clique para acessar o Prof. Tilap-IA"><div class="professor-image-aligned"><span class="emoji-fallback-aligned">üêüü§ì</span></div></a>'
            st.markdown(html_fallback, unsafe_allow_html=True)

        # Texto perfeitamente centralizado
        st.markdown('<div class="professor-text-center"><p>üëÜ Clique na imagem para acessar nosso consultor virtual Dr. Tilap-IA!</p></div>',
                    unsafe_allow_html=True)

        # Fechar container
        st.markdown('</div>', unsafe_allow_html=True)


def main():
    st.markdown('<h1 class="main-header">üêü Aquicultura Analytics Pro</h1>',
                unsafe_allow_html=True)

    # Session state
    if 'processed_data' not in st.session_state:
        st.session_state.processed_data = None
    if 'sheets_data' not in st.session_state:
        st.session_state.sheets_data = None
    if 'analysis_results' not in st.session_state:
        st.session_state.analysis_results = None

    # Adicionar bot√£o do Prof. Tilap-IA (SINTAXE CORRIGIDA)
    add_consultor_icon()

    # Sidebar com filtros avan√ßados
    with st.sidebar:
        st.header("üîó Conex√£o e Filtros")

        # Carregar dados - CHAVE √öNICA ADICIONADA
        if st.button("üîÑ Carregar/Atualizar Dados", type="primary", use_container_width=True,
                     key="btn_carregar_dados_main"):
            with st.spinner("Carregando dados do Google Sheets..."):
                data, errors = load_sheets()

                if data:
                    st.session_state.sheets_data = data
                    for name, df in data.items():
                        st.success(f"‚úÖ {name}: {len(df)} registros")

                if errors:
                    for name, error in errors.items():
                        st.error(f"‚ùå {name}: {error}")

        # Filtros avan√ßados
        if st.session_state.sheets_data:
            st.markdown('<div class="filter-section">', unsafe_allow_html=True)

            # a) Sele√ß√£o de per√≠odo
            st.subheader("üìÖ Per√≠odo de An√°lise")

            fish_df = st.session_state.sheets_data.get('tilapias')
            if fish_df is not None:
                fish_df['data'] = pd.to_datetime(fish_df['data'], errors='coerce')
                valid_dates = fish_df['data'].dropna()

                if not valid_dates.empty:
                    min_date = valid_dates.min().date()
                    max_date = valid_dates.max().date()
                else:
                    min_date = date.today() - timedelta(days=30)
                    max_date = date.today()
            else:
                min_date = date.today() - timedelta(days=30)
                max_date = date.today()

            col1, col2 = st.columns(2)
            with col1:
                start_date = st.date_input(
                    "üìÖ Data Inicial",
                    value=min_date,
                    format="DD/MM/YYYY",
                    key="date_inicio_main"
                )
            with col2:
                end_date = st.date_input(
                    "üìÖ Data Final",
                    value=max_date,
                    format="DD/MM/YYYY",
                    key="date_fim_main"
                )

            # b) Sele√ß√£o de tanques
            st.subheader("üèä Sele√ß√£o de Tanques")

            feed_df = st.session_state.sheets_data.get('racao')
            if feed_df is not None:
                available_tanks = sorted([t for t in feed_df['tanque'].unique() if pd.notna(t)])

                # Op√ß√£o "Todos os tanques"
                all_tanks = st.checkbox("‚úÖ Selecionar todos os tanques", value=True, key="checkbox_todos_tanques_main")

                if all_tanks:
                    selected_tanks = available_tanks
                else:
                    selected_tanks = st.multiselect(
                        "Escolha os tanques:",
                        available_tanks,
                        default=available_tanks[:3] if len(available_tanks) > 3 else available_tanks,
                        key="multiselect_tanques_main"
                    )
            else:
                selected_tanks = []

            # c) N√≠vel de confian√ßa
            st.subheader("üìä Configura√ß√µes Estat√≠sticas")
            confidence_level = st.selectbox(
                "üéØ N√≠vel de Confian√ßa:",
                [90, 95, 99],
                index=1,
                help="N√≠vel de confian√ßa para intervalos estat√≠sticos",
                key="selectbox_confianca_main"
            )

            # Par√¢metros adicionais
            correction_factor = st.slider(
                "üîß Fator de Corre√ß√£o do Peso:",
                0.5, 2.0, 1.0, 0.1,
                help="Ajuste fino para c√°lculo do peso estimado",
                key="slider_correcao_main"
            )

            st.markdown('</div>', unsafe_allow_html=True)

            # Bot√£o de processamento - CHAVE √öNICA ADICIONADA
            if st.button("üöÄ Processar An√°lise Completa", use_container_width=True, key="btn_processar_analise_main"):
                with st.spinner("Processando an√°lises avan√ßadas..."):
                    try:
                        # Processar dados
                        processed_data = process_advanced_data(
                            st.session_state.sheets_data,
                            start_date, end_date, selected_tanks,
                            confidence_level, correction_factor
                        )

                        # An√°lises estat√≠sticas
                        analysis_results = perform_advanced_analysis(
                            processed_data, confidence_level
                        )

                        st.session_state.processed_data = processed_data
                        st.session_state.analysis_results = analysis_results

                        st.success("‚úÖ An√°lise completa conclu√≠da!")
                        st.rerun()

                    except Exception as e:
                        st.error(f"‚ùå Erro no processamento: {e}")
                        import traceback
                        st.code(traceback.format_exc())

    # √Årea principal
    if st.session_state.processed_data is not None:
        display_advanced_dashboard()
    elif st.session_state.sheets_data:
        display_data_preview()
    else:
        display_welcome_advanced()


def process_advanced_data(sheets_data, start_date, end_date, selected_tanks, confidence_level, correction_factor):
    """Processamento avan√ßado dos dados"""

    fish_df = sheets_data.get('tilapias')
    feed_df = sheets_data.get('racao')

    if fish_df is None or feed_df is None:
        raise ValueError("Dados n√£o dispon√≠veis")

    # Limpar e preparar dados dos peixes
    fish_clean = fish_df.copy()
    fish_clean['data'] = pd.to_datetime(fish_clean['data'], errors='coerce')
    fish_clean['largura'] = pd.to_numeric(fish_clean['largura'], errors='coerce')
    fish_clean['altura'] = pd.to_numeric(fish_clean['altura'], errors='coerce')

    # Limpar dados ambientais se existirem
    env_columns = ['temperatura', 'ph', 'o2']
    for col in env_columns:
        if col in fish_clean.columns:
            fish_clean[col] = pd.to_numeric(fish_clean[col], errors='coerce')

    # Filtrar por per√≠odo
    mask = (fish_clean['data'].dt.date >= start_date) & (fish_clean['data'].dt.date <= end_date)
    fish_filtered = fish_clean[mask]

    # Remover dados inv√°lidos
    fish_filtered = fish_filtered.dropna(subset=['data', 'largura', 'altura'])
    fish_filtered = fish_filtered[(fish_filtered['largura'] > 0) & (fish_filtered['altura'] > 0)]

    # Calcular peso estimado com fatores ambientais
    fish_filtered['peso_estimado'] = calculate_advanced_weight(fish_filtered, correction_factor)

    # Agrupar por data e tanque
    agg_dict = {
        'peso_estimado': ['mean', 'std', 'count', 'sum', 'min', 'max'],
        'largura': ['mean', 'std'],
        'altura': ['mean', 'std']
    }

    # Adicionar dados ambientais
    for col in env_columns:
        if col in fish_filtered.columns:
            agg_dict[col] = ['mean', 'std']

    fish_grouped = fish_filtered.groupby(['data', 'tanque']).agg(agg_dict).reset_index()

    # Flatten column names
    new_columns = ['data', 'tanque', 'peso_medio', 'peso_std', 'n_peixes', 'peso_total', 'peso_min', 'peso_max',
                   'largura_media', 'largura_std', 'altura_media', 'altura_std']

    for col in env_columns:
        if col in fish_filtered.columns:
            new_columns.extend([f'{col}_medio', f'{col}_std'])

    fish_grouped.columns = new_columns

    # Processar dados de ra√ß√£o
    feed_clean = feed_df.copy()
    feed_clean['data'] = pd.to_datetime(feed_clean['data'], errors='coerce')
    feed_clean['peso'] = pd.to_numeric(feed_clean['peso'], errors='coerce')

    # Filtrar ra√ß√£o por per√≠odo e tanques
    mask_feed = (feed_clean['data'].dt.date >= start_date) & (feed_clean['data'].dt.date <= end_date)
    feed_filtered = feed_clean[mask_feed]

    if selected_tanks:
        feed_filtered = feed_filtered[feed_filtered['tanque'].isin(selected_tanks)]

    # Agrupar ra√ß√£o
    feed_grouped = feed_filtered.groupby(['data', 'tanque'])['peso'].agg(['sum', 'count', 'mean']).reset_index()
    feed_grouped.columns = ['data', 'tanque', 'total_racao', 'n_alimentacoes', 'racao_media']

    # Integrar dados
    integrated = pd.merge(fish_grouped, feed_grouped, on=['data', 'tanque'], how='left')
    integrated = integrated.fillna(0)

    # Calcular m√©tricas avan√ßadas
    integrated['eficiencia_alimentar'] = integrated.apply(
        lambda row: row['peso_total'] / row['total_racao'] if row['total_racao'] > 0 else 0,
        axis=1
    )

    integrated['consumo_per_capita'] = integrated.apply(
        lambda row: row['total_racao'] / row['n_peixes'] if row['n_peixes'] > 0 else 0,
        axis=1
    )

    # Taxa de convers√£o alimentar (TCA)
    integrated = calculate_feed_conversion_rate(integrated)

    # Calcular crescimento di√°rio
    integrated = calculate_daily_growth(integrated)

    return integrated


def calculate_advanced_weight(fish_data, correction_factor):
    """C√°lculo avan√ßado de peso com fatores ambientais"""

    # Par√¢metros base
    densidade_peixe = 1.05  # kg/L
    fator_forma = 0.7
    fator_profundidade = 0.6

    # C√°lculo do volume
    profundidade_estimada = fish_data['largura'] * fator_profundidade
    volume_cm3 = fish_data['largura'] * fish_data['altura'] * profundidade_estimada * fator_forma
    volume_litros = volume_cm3 / 1000

    # Peso base
    peso_base = volume_litros * densidade_peixe * correction_factor

    # Fatores ambientais
    fator_ambiental = pd.Series(1.0, index=fish_data.index)

    # Corre√ß√£o por temperatura
    if 'temperatura' in fish_data.columns:
        temp = fish_data['temperatura']
        temp_factor = temp.apply(lambda t:
                                 1.0 if pd.isna(t) else
                                 1.0 if 26 <= t <= 30 else
                                 0.98 if 24 <= t <= 32 else
                                 0.95 if 22 <= t <= 34 else
                                 0.90 if 20 <= t <= 36 else 0.85
                                 )
        fator_ambiental *= temp_factor

    # Corre√ß√£o por pH
    if 'ph' in fish_data.columns:
        ph = fish_data['ph']
        ph_factor = ph.apply(lambda p:
                             1.0 if pd.isna(p) else
                             1.0 if 6.5 <= p <= 8.5 else
                             0.98 if 6.0 <= p <= 9.0 else
                             0.95 if 5.5 <= p <= 9.5 else 0.90
                             )
        fator_ambiental *= ph_factor

    # Corre√ß√£o por O2
    if 'o2' in fish_data.columns:
        o2 = fish_data['o2']
        o2_factor = o2.apply(lambda o:
                             1.0 if pd.isna(o) else
                             1.0 if o >= 5 else
                             0.98 if o >= 4 else
                             0.95 if o >= 3 else
                             0.90 if o >= 2 else 0.80
                             )
        fator_ambiental *= o2_factor

    peso_final = peso_base * fator_ambiental
    return peso_final.clip(0.01, 50.0)

# CONTINUA NA PARTE 2
# CONTINUA√á√ÉO DA PARTE 1 - Fun√ß√µes de C√°lculo e An√°lise

def calculate_feed_conversion_rate(data):
    """Calcula a Taxa de Convers√£o Alimentar (TCA)"""

    # Ordenar por tanque e data
    data = data.sort_values(['tanque', 'data'])

    # Calcular TCA por tanque
    tca_results = []

    for tanque in data['tanque'].unique():
        tank_data = data[data['tanque'] == tanque].copy()

        if len(tank_data) < 2:
            continue

        # Peso inicial e final
        peso_inicial = tank_data['peso_medio'].iloc[0]
        peso_final = tank_data['peso_medio'].iloc[-1]

        # Total de ra√ß√£o no per√≠odo
        total_racao_periodo = tank_data['total_racao'].sum()

        # Ganho de peso
        ganho_peso = peso_final - peso_inicial

        # TCA = Ra√ß√£o fornecida / Ganho de peso
        if ganho_peso > 0:
            tca = total_racao_periodo / ganho_peso
        else:
            tca = 0

        # Adicionar TCA a todos os registros do tanque
        tank_data['tca_periodo'] = tca
        tank_data['peso_inicial'] = peso_inicial
        tank_data['peso_final'] = peso_final
        tank_data['ganho_peso'] = ganho_peso

        tca_results.append(tank_data)

    if tca_results:
        return pd.concat(tca_results, ignore_index=True)
    else:
        data['tca_periodo'] = 0
        data['peso_inicial'] = 0
        data['peso_final'] = 0
        data['ganho_peso'] = 0
        return data


def calculate_daily_growth(data):
    """Calcula crescimento di√°rio"""

    data = data.sort_values(['tanque', 'data'])

    # Calcular crescimento di√°rio por tanque
    growth_results = []

    for tanque in data['tanque'].unique():
        tank_data = data[data['tanque'] == tanque].copy()

        # Calcular diferen√ßa de peso entre dias consecutivos
        tank_data['crescimento_diario'] = tank_data['peso_medio'].diff()

        # Calcular taxa de crescimento percentual
        tank_data['taxa_crescimento_pct'] = (
                tank_data['peso_medio'].pct_change() * 100
        )

        # Crescimento acumulado
        tank_data['crescimento_acumulado'] = (
                tank_data['peso_medio'] - tank_data['peso_medio'].iloc[0]
        )

        growth_results.append(tank_data)

    if growth_results:
        return pd.concat(growth_results, ignore_index=True)
    else:
        data['crescimento_diario'] = 0
        data['taxa_crescimento_pct'] = 0
        data['crescimento_acumulado'] = 0
        return data


def perform_advanced_analysis(data, confidence_level):
    """Realiza an√°lises estat√≠sticas avan√ßadas"""

    results = {}

    # 1. An√°lise de correla√ß√£o
    numeric_cols = data.select_dtypes(include=[np.number]).columns
    correlation_matrix = data[numeric_cols].corr()
    results['correlations'] = correlation_matrix

    # 2. Regress√£o linear: Ra√ß√£o vs Peso
    if 'total_racao' in data.columns and 'peso_medio' in data.columns:
        X = data[['total_racao']].values
        y = data['peso_medio'].values

        # Remover valores nulos
        mask = ~(np.isnan(X.flatten()) | np.isnan(y))
        X_clean = X[mask].reshape(-1, 1)
        y_clean = y[mask]

        if len(X_clean) > 1:
            model = LinearRegression()
            model.fit(X_clean, y_clean)
            y_pred = model.predict(X_clean)

            results['regression'] = {
                'slope': model.coef_[0],
                'intercept': model.intercept_,
                'r2': r2_score(y_clean, y_pred),
                'predictions': y_pred,
                'X': X_clean.flatten(),
                'y': y_clean
            }

    # 3. Estat√≠sticas descritivas avan√ßadas
    peso_stats = calculate_advanced_statistics(data['peso_medio'], confidence_level)
    results['peso_statistics'] = peso_stats

    if 'eficiencia_alimentar' in data.columns:
        eff_stats = calculate_advanced_statistics(data['eficiencia_alimentar'], confidence_level)
        results['efficiency_statistics'] = eff_stats

    # 4. An√°lise de distribui√ß√£o (teste de normalidade)
    if len(data['peso_medio'].dropna()) > 3:
        shapiro_stat, shapiro_p = stats.shapiro(data['peso_medio'].dropna())
        results['normality_test'] = {
            'shapiro_stat': shapiro_stat,
            'shapiro_p': shapiro_p,
            'is_normal': shapiro_p > 0.05
        }

    # 5. An√°lise por tanque
    tank_analysis = {}
    for tanque in data['tanque'].unique():
        tank_data = data[data['tanque'] == tanque]
        tank_analysis[tanque] = {
            'peso_medio': tank_data['peso_medio'].mean(),
            'peso_std': tank_data['peso_medio'].std(),
            'eficiencia_media': tank_data['eficiencia_alimentar'].mean(),
            'tca_media': tank_data['tca_periodo'].mean() if 'tca_periodo' in tank_data.columns else 0,
            'n_registros': len(tank_data)
        }

    results['tank_analysis'] = tank_analysis

    return results


def calculate_advanced_statistics(series, confidence_level):
    """Calcula estat√≠sticas avan√ßadas com intervalo de confian√ßa"""

    clean_data = series.dropna()

    if len(clean_data) == 0:
        return {}

    # Estat√≠sticas b√°sicas
    mean = clean_data.mean()
    std = clean_data.std()
    median = clean_data.median()

    # Intervalo de confian√ßa
    alpha = 1 - (confidence_level / 100)
    dof = len(clean_data) - 1

    if dof > 0:
        t_critical = stats.t.ppf(1 - alpha / 2, dof)
        margin_error = t_critical * (std / np.sqrt(len(clean_data)))
        ci_lower = mean - margin_error
        ci_upper = mean + margin_error
    else:
        ci_lower = ci_upper = mean

    # Quartis
    q1 = clean_data.quantile(0.25)
    q3 = clean_data.quantile(0.75)
    iqr = q3 - q1

    # Assimetria e curtose
    skewness = stats.skew(clean_data)
    kurtosis = stats.kurtosis(clean_data)

    return {
        'mean': mean,
        'std': std,
        'median': median,
        'min': clean_data.min(),
        'max': clean_data.max(),
        'q1': q1,
        'q3': q3,
        'iqr': iqr,
        'skewness': skewness,
        'kurtosis': kurtosis,
        'ci_lower': ci_lower,
        'ci_upper': ci_upper,
        'confidence_level': confidence_level,
        'count': len(clean_data)
    }


def display_advanced_dashboard():
    """Dashboard avan√ßado com todas as an√°lises"""

    data = st.session_state.processed_data
    analysis = st.session_state.analysis_results

    # KPIs Avan√ßados
    display_advanced_kpis(data)

    # Abas principais
    tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
        "üìä An√°lise Temporal",
        "üìà Taxa de Convers√£o",
        "üìâ Curva de Gauss",
        "üî¨ Estat√≠sticas Avan√ßadas",
        "ü§ñ Assistente IA",
        "üìã Relat√≥rios",
        "üíæ Exporta√ß√£o"
    ])

    with tab1:
        display_temporal_analysis(data)

    with tab2:
        display_feed_conversion_analysis(data)

    with tab3:
        display_gaussian_analysis(data, analysis)

    with tab4:
        display_advanced_statistics(data, analysis)

    with tab5:
        display_ai_assistant_placeholder()

    with tab6:
        display_automated_reports(data, analysis)

    with tab7:
        display_advanced_export(data, analysis)


def display_advanced_kpis(data):
    """KPIs avan√ßados"""

    st.markdown('<div class="analysis-section">', unsafe_allow_html=True)
    st.subheader("üìä Indicadores de Performance Avan√ßados")

    col1, col2, col3, col4, col5 = st.columns(5)

    with col1:
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        peso_medio = data['peso_medio'].mean()
        peso_trend = ((data['peso_medio'].iloc[-1] - data['peso_medio'].iloc[0]) / data['peso_medio'].iloc[
            0] * 100) if len(data) > 1 else 0
        st.metric("üêü Peso M√©dio", f"{peso_medio:.3f} kg", f"{peso_trend:+.1f}%")
        st.markdown('</div>', unsafe_allow_html=True)

    with col2:
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        eff_media = data['eficiencia_alimentar'].mean()
        st.metric("‚ö° Efici√™ncia Alimentar", f"{eff_media:.2f}")
        st.markdown('</div>', unsafe_allow_html=True)

    with col3:
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        if 'tca_periodo' in data.columns:
            tca_media = data['tca_periodo'].mean()
            st.metric("üîÑ TCA M√©dia", f"{tca_media:.2f}")
        else:
            st.metric("üîÑ TCA M√©dia", "N/A")
        st.markdown('</div>', unsafe_allow_html=True)

    with col4:
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        if 'crescimento_diario' in data.columns:
            crescimento = data['crescimento_diario'].mean()
            st.metric("üìà Crescimento Di√°rio", f"{crescimento:.4f} kg")
        else:
            st.metric("üìà Crescimento Di√°rio", "N/A")
        st.markdown('</div>', unsafe_allow_html=True)

    with col5:
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        total_racao = data['total_racao'].sum()
        st.metric("üçΩÔ∏è Ra√ß√£o Total", f"{total_racao:.1f} kg")
        st.markdown('</div>', unsafe_allow_html=True)

    st.markdown('</div>', unsafe_allow_html=True)


def display_temporal_analysis(data):
    """An√°lise temporal da rela√ß√£o peso x ra√ß√£o"""

    st.subheader("üìä An√°lise Temporal: Peso vs Ra√ß√£o")

    # Gr√°fico principal de evolu√ß√£o
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            "Evolu√ß√£o do Peso M√©dio por Tanque",
            "Consumo de Ra√ß√£o por Tanque",
            "Efici√™ncia Alimentar no Tempo",
            "Crescimento Acumulado"
        ),
        specs=[[{"secondary_y": True}, {"secondary_y": False}],
               [{"secondary_y": False}, {"secondary_y": False}]]
    )

    colors = px.colors.qualitative.Set3

    # Gr√°fico 1: Peso m√©dio
    for i, tanque in enumerate(data['tanque'].unique()):
        tank_data = data[data['tanque'] == tanque]
        fig.add_trace(
            go.Scatter(
                x=tank_data['data'],
                y=tank_data['peso_medio'],
                mode='lines+markers',
                name=f'Tanque {tanque}',
                line=dict(color=colors[i % len(colors)], width=2),
                legendgroup=f'tanque_{tanque}'
            ),
            row=1, col=1
        )

    # Gr√°fico 2: Ra√ß√£o
    for i, tanque in enumerate(data['tanque'].unique()):
        tank_data = data[data['tanque'] == tanque]
        fig.add_trace(
            go.Bar(
                x=tank_data['data'],
                y=tank_data['total_racao'],
                name=f'Ra√ß√£o T{tanque}',
                marker_color=colors[i % len(colors)],
                opacity=0.7,
                legendgroup=f'tanque_{tanque}',
                showlegend=False
            ),
            row=1, col=2
        )

    # Gr√°fico 3: Efici√™ncia
    for i, tanque in enumerate(data['tanque'].unique()):
        tank_data = data[data['tanque'] == tanque]
        fig.add_trace(
            go.Scatter(
                x=tank_data['data'],
                y=tank_data['eficiencia_alimentar'],
                mode='lines+markers',
                name=f'Eff T{tanque}',
                line=dict(color=colors[i % len(colors)], dash='dash'),
                legendgroup=f'tanque_{tanque}',
                showlegend=False
            ),
            row=2, col=1
        )

    # Gr√°fico 4: Crescimento acumulado
    if 'crescimento_acumulado' in data.columns:
        for i, tanque in enumerate(data['tanque'].unique()):
            tank_data = data[data['tanque'] == tanque]
            fig.add_trace(
                go.Scatter(
                    x=tank_data['data'],
                    y=tank_data['crescimento_acumulado'],
                    mode='lines+markers',
                    name=f'Cresc T{tanque}',
                    line=dict(color=colors[i % len(colors)], width=3),
                    fill='tonexty' if i > 0 else None,
                    legendgroup=f'tanque_{tanque}',
                    showlegend=False
                ),
                row=2, col=2
            )

    fig.update_layout(
        title="An√°lise Temporal Completa",
        height=700,
        template="plotly_white",
        showlegend=True
    )

    fig.update_yaxes(title_text="Peso (kg)", row=1, col=1)
    fig.update_yaxes(title_text="Ra√ß√£o (kg)", row=1, col=2)
    fig.update_yaxes(title_text="Efici√™ncia", row=2, col=1)
    fig.update_yaxes(title_text="Crescimento Acum. (kg)", row=2, col=2)

    st.plotly_chart(fig, use_container_width=True)

    # An√°lise de correla√ß√£o temporal
    st.subheader("üîó Correla√ß√£o Peso x Ra√ß√£o no Tempo")

    # Scatter plot com linha de tend√™ncia
    fig_scatter = go.Figure()

    for i, tanque in enumerate(data['tanque'].unique()):
        tank_data = data[data['tanque'] == tanque]

        fig_scatter.add_trace(
            go.Scatter(
                x=tank_data['total_racao'],
                y=tank_data['peso_medio'],
                mode='markers',
                name=f'Tanque {tanque}',
                marker=dict(
                    size=8,
                    color=colors[i % len(colors)],
                    opacity=0.7
                ),
                text=tank_data['data'].dt.strftime('%d/%m/%Y'),
                hovertemplate='<b>Tanque %{fullData.name}</b><br>' +
                              'Ra√ß√£o: %{x:.2f} kg<br>' +
                              'Peso: %{y:.3f} kg<br>' +
                              'Data: %{text}<extra></extra>'
            )
        )

    # Linha de tend√™ncia geral
    if len(data) > 1:
        z = np.polyfit(data['total_racao'], data['peso_medio'], 1)
        p = np.poly1d(z)
        x_trend = np.linspace(data['total_racao'].min(), data['total_racao'].max(), 100)
        y_trend = p(x_trend)

        # Calcular R¬≤
        correlation = np.corrcoef(data['total_racao'], data['peso_medio'])[0, 1]
        r2 = correlation ** 2

        fig_scatter.add_trace(
            go.Scatter(
                x=x_trend,
                y=y_trend,
                mode='lines',
                name=f'Tend√™ncia (R¬≤ = {r2:.3f})',
                line=dict(color='red', width=3, dash='dash')
            )
        )

    fig_scatter.update_layout(
        title="Correla√ß√£o: Consumo de Ra√ß√£o vs Peso M√©dio",
        xaxis_title="Ra√ß√£o Consumida (kg)",
        yaxis_title="Peso M√©dio (kg)",
        template="plotly_white",
        height=500
    )

    st.plotly_chart(fig_scatter, use_container_width=True)


def display_feed_conversion_analysis(data):
    """An√°lise da Taxa de Convers√£o Alimentar"""

    st.subheader("üîÑ Taxa de Convers√£o Alimentar (TCA)")

    if 'tca_periodo' not in data.columns:
        st.warning("‚ö†Ô∏è Dados de TCA n√£o dispon√≠veis")
        return

    # Informa√ß√µes sobre TCA
    st.info("""
    **Taxa de Convers√£o Alimentar (TCA)** = Quantidade de ra√ß√£o fornecida (kg) √∑ (Peso final - Peso inicial) (kg)

    - **TCA < 1.5**: Excelente efici√™ncia
    - **TCA 1.5-2.0**: Boa efici√™ncia  
    - **TCA 2.0-2.5**: Efici√™ncia regular
    - **TCA > 2.5**: Baixa efici√™ncia
    """)

    # M√©tricas de TCA
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        tca_media = data['tca_periodo'].mean()
        st.metric("üìä TCA M√©dia Geral", f"{tca_media:.2f}")
        st.markdown('</div>', unsafe_allow_html=True)

    with col2:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        tca_melhor = data['tca_periodo'].min()
        st.metric("üèÜ Melhor TCA", f"{tca_melhor:.2f}")
        st.markdown('</div>', unsafe_allow_html=True)

    with col3:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        tca_pior = data['tca_periodo'].max()
        st.metric("‚ö†Ô∏è Pior TCA", f"{tca_pior:.2f}")
        st.markdown('</div>', unsafe_allow_html=True)

    with col4:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        ganho_total = data['ganho_peso'].sum()
        st.metric("üìà Ganho Total", f"{ganho_total:.2f} kg")
        st.markdown('</div>', unsafe_allow_html=True)

    # Gr√°fico de TCA por tanque
    fig_tca = go.Figure()

    tank_tca = data.groupby('tanque')['tca_periodo'].first()  # TCA √© constante por tanque

    # Definir cores baseadas na efici√™ncia
    colors_tca = []
    for tca in tank_tca.values:
        if tca < 1.5:
            colors_tca.append('#10b981')  # Verde - Excelente
        elif tca < 2.0:
            colors_tca.append('#3b82f6')  # Azul - Bom
        elif tca < 2.5:
            colors_tca.append('#f59e0b')  # Amarelo - Regular
        else:
            colors_tca.append('#ef4444')  # Vermelho - Baixo

    fig_tca.add_trace(
        go.Bar(
            x=[f'Tanque {t}' for t in tank_tca.index],
            y=tank_tca.values,
            marker_color=colors_tca,
            text=[f'{tca:.2f}' for tca in tank_tca.values],
            textposition='auto',
            name='TCA por Tanque'
        )
    )

    # Linhas de refer√™ncia
    fig_tca.add_hline(y=1.5, line_dash="dash", line_color="green",
                      annotation_text="Excelente (< 1.5)")
    fig_tca.add_hline(y=2.0, line_dash="dash", line_color="blue",
                      annotation_text="Bom (< 2.0)")
    fig_tca.add_hline(y=2.5, line_dash="dash", line_color="orange",
                      annotation_text="Regular (< 2.5)")

    fig_tca.update_layout(
        title="Taxa de Convers√£o Alimentar por Tanque",
        xaxis_title="Tanque",
        yaxis_title="TCA (kg ra√ß√£o / kg ganho)",
        template="plotly_white",
        height=500
    )

    st.plotly_chart(fig_tca, use_container_width=True)

    # Tabela detalhada de TCA
    st.subheader("üìã Detalhamento da TCA por Tanque")

    tca_summary = []
    for tanque in data['tanque'].unique():
        tank_data = data[data['tanque'] == tanque].iloc[0]  # Pegar primeiro registro (TCA √© constante)

        status = "üü¢ Excelente" if tank_data['tca_periodo'] < 1.5 else \
            "üîµ Bom" if tank_data['tca_periodo'] < 2.0 else \
                "üü° Regular" if tank_data['tca_periodo'] < 2.5 else \
                    "üî¥ Baixo"

        tca_summary.append({
            'Tanque': f'Tanque {tanque}',
            'Peso Inicial (kg)': f"{tank_data['peso_inicial']:.3f}",
            'Peso Final (kg)': f"{tank_data['peso_final']:.3f}",
            'Ganho de Peso (kg)': f"{tank_data['ganho_peso']:.3f}",
            'Ra√ß√£o Total (kg)': f"{data[data['tanque'] == tanque]['total_racao'].sum():.2f}",
            'TCA': f"{tank_data['tca_periodo']:.2f}",
            'Status': status
        })

    tca_df = pd.DataFrame(tca_summary)
    st.dataframe(tca_df, use_container_width=True, hide_index=True)


def display_ai_assistant_placeholder():
    """Placeholder para o assistente de IA"""

    st.subheader("ü§ñ Assistente de IA - Interpreta√ß√£o Inteligente")

    st.info("""
    **üöÄ Funcionalidade em Desenvolvimento**

    O Assistente de IA Prof. Tilap-IA est√° dispon√≠vel atrav√©s do √≠cone flutuante no canto inferior direito da tela.

    **Funcionalidades dispon√≠veis:**
    - üìä An√°lises r√°pidas e personalizadas
    - üí¨ Chat interativo sobre seus dados
    - üìã Relat√≥rios automatizados com IA
    - üí° Recomenda√ß√µes espec√≠ficas para aquicultura

    **Como usar:**
    1. Clique no √≠cone do Prof. Tilap-IA (üßë‚Äçüè´)
    2. Acesse o assistente especializado
    3. Fa√ßa perguntas sobre seus dados
    4. Receba insights e recomenda√ß√µes
    """)

    # Bot√£o para acessar o assistente
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("üöÄ Acessar Prof. Tilap-IA", use_container_width=True, key="btn_acesso_ia_main"):
            st.markdown("""
            <script>
            window.open('https://ffastia-bia-rag-bia-chain-mem-vgkrw6.streamlit.app/', '_blank');
            </script>
            """, unsafe_allow_html=True)
            st.success("‚úÖ Abrindo Prof. Tilap-IA em nova aba...")

# CONTINUA NA PARTE 3
# CONTINUA√á√ÉO DA PARTE 2 - An√°lise Gaussiana e Estat√≠sticas Avan√ßadas

def display_gaussian_analysis(data, analysis):
    """An√°lise da Curva de Gauss (Distribui√ß√£o Normal)"""

    st.subheader("üìâ Curva de Gauss - Distribui√ß√£o do Peso dos Peixes")

    peso_data = data['peso_medio'].dropna()

    if len(peso_data) == 0:
        st.warning("‚ö†Ô∏è Dados de peso n√£o dispon√≠veis")
        return

    # Estat√≠sticas da distribui√ß√£o
    mean = peso_data.mean()
    std = peso_data.std()

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        st.metric("üìä M√©dia (Œº)", f"{mean:.3f} kg")
        st.markdown('</div>', unsafe_allow_html=True)

    with col2:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        st.metric("üìè Desvio Padr√£o (œÉ)", f"{std:.3f} kg")
        st.markdown('</div>', unsafe_allow_html=True)

    with col3:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        cv = (std / mean) * 100 if mean != 0 else 0
        st.metric("üìà Coef. Varia√ß√£o", f"{cv:.1f}%")
        st.markdown('</div>', unsafe_allow_html=True)

    with col4:
        st.markdown('<div class="stat-card">', unsafe_allow_html=True)
        st.metric("üî¢ Amostras", f"{len(peso_data)}")
        st.markdown('</div>', unsafe_allow_html=True)

    # Gr√°fico da distribui√ß√£o com curva de Gauss
    fig = go.Figure()

    # Histograma dos dados reais
    fig.add_trace(
        go.Histogram(
            x=peso_data,
            nbinsx=25,
            name='Distribui√ß√£o Observada',
            opacity=0.7,
            marker_color='lightblue',
            histnorm='probability density'
        )
    )

    # Curva de Gauss te√≥rica
    x_range = np.linspace(peso_data.min() - 2 * std, peso_data.max() + 2 * std, 100)
    y_gauss = stats.norm.pdf(x_range, mean, std)

    fig.add_trace(
        go.Scatter(
            x=x_range,
            y=y_gauss,
            mode='lines',
            name='Curva de Gauss Te√≥rica',
            line=dict(color='red', width=3)
        )
    )

    # Linhas de refer√™ncia (Œº ¬± œÉ)
    fig.add_vline(x=mean, line_dash="dash", line_color="green",
                  annotation_text=f"Œº = {mean:.3f}")
    fig.add_vline(x=mean - std, line_dash="dot", line_color="orange",
                  annotation_text=f"Œº - œÉ")
    fig.add_vline(x=mean + std, line_dash="dot", line_color="orange",
                  annotation_text=f"Œº + œÉ")

    fig.update_layout(
        title=f"Distribui√ß√£o Normal do Peso (Œº={mean:.3f}, œÉ={std:.3f})",
        xaxis_title="Peso (kg)",
        yaxis_title="Densidade de Probabilidade",
        template="plotly_white",
        height=500
    )

    st.plotly_chart(fig, use_container_width=True)

    # Teste de normalidade
    if 'normality_test' in analysis:
        st.subheader("üî¨ Teste de Normalidade (Shapiro-Wilk)")

        normality = analysis['normality_test']

        col1, col2 = st.columns(2)

        with col1:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.metric("üìä Estat√≠stica W", f"{normality['shapiro_stat']:.4f}")
            st.markdown('</div>', unsafe_allow_html=True)

        with col2:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.metric("üìà p-valor", f"{normality['shapiro_p']:.4f}")
            st.markdown('</div>', unsafe_allow_html=True)

        if normality['is_normal']:
            st.success("‚úÖ **Distribui√ß√£o Normal**: Os dados seguem uma distribui√ß√£o normal (p > 0.05)")
        else:
            st.warning("‚ö†Ô∏è **Distribui√ß√£o N√£o-Normal**: Os dados n√£o seguem uma distribui√ß√£o normal (p ‚â§ 0.05)")

    # An√°lise por percentis
    st.subheader("üìä An√°lise por Percentis")

    percentiles = [5, 10, 25, 50, 75, 90, 95]
    perc_values = [np.percentile(peso_data, p) for p in percentiles]

    perc_df = pd.DataFrame({
        'Percentil': [f'P{p}' for p in percentiles],
        'Valor (kg)': [f'{v:.3f}' for v in perc_values],
        'Interpreta√ß√£o': [
            'Muito baixo', 'Baixo', 'Abaixo da m√©dia', 'Mediana',
            'Acima da m√©dia', 'Alto', 'Muito alto'
        ]
    })

    st.dataframe(perc_df, use_container_width=True, hide_index=True)


def display_advanced_statistics(data, analysis):
    """Exibe estat√≠sticas avan√ßadas e correla√ß√µes"""

    st.subheader("üî¨ An√°lises Estat√≠sticas Avan√ßadas")

    # Matriz de correla√ß√£o
    if 'correlations' in analysis:
        st.subheader("üìä Matriz de Correla√ß√£o")

        corr_matrix = analysis['correlations']

        # Filtrar apenas correla√ß√µes relevantes
        relevant_cols = ['peso_medio', 'total_racao', 'eficiencia_alimentar', 'n_peixes']
        if 'tca_periodo' in corr_matrix.columns:
            relevant_cols.append('tca_periodo')

        available_cols = [col for col in relevant_cols if col in corr_matrix.columns]

        if len(available_cols) > 1:
            corr_subset = corr_matrix.loc[available_cols, available_cols]

            # Heatmap de correla√ß√£o
            fig_corr = go.Figure(data=go.Heatmap(
                z=corr_subset.values,
                x=corr_subset.columns,
                y=corr_subset.columns,
                colorscale='RdBu',
                zmid=0,
                text=corr_subset.round(3).values,
                texttemplate="%{text}",
                textfont={"size": 12},
                hoverongaps=False
            ))

            fig_corr.update_layout(
                title="Matriz de Correla√ß√£o entre Vari√°veis",
                height=500,
                template="plotly_white"
            )

            st.plotly_chart(fig_corr, use_container_width=True)

            # Interpreta√ß√£o das correla√ß√µes
            st.subheader("üîç Interpreta√ß√£o das Correla√ß√µes")

            strong_correlations = []
            for i in range(len(available_cols)):
                for j in range(i + 1, len(available_cols)):
                    corr_value = corr_subset.iloc[i, j]
                    var1 = available_cols[i]
                    var2 = available_cols[j]

                    if abs(corr_value) > 0.7:
                        strength = "muito forte"
                        color = "üî¥" if corr_value > 0 else "üîµ"
                    elif abs(corr_value) > 0.5:
                        strength = "forte"
                        color = "üü†" if corr_value > 0 else "üü¶"
                    elif abs(corr_value) > 0.3:
                        strength = "moderada"
                        color = "üü°" if corr_value > 0 else "üü™"
                    else:
                        continue

                    direction = "positiva" if corr_value > 0 else "negativa"
                    strong_correlations.append(
                        f"{color} **{var1}** vs **{var2}**: Correla√ß√£o {strength} {direction} (r = {corr_value:.3f})"
                    )

            if strong_correlations:
                for corr_text in strong_correlations:
                    st.write(corr_text)
            else:
                st.info("‚ÑπÔ∏è N√£o foram encontradas correla√ß√µes significativas (|r| > 0.3)")

    # Regress√£o linear
    if 'regression' in analysis:
        st.subheader("üìà An√°lise de Regress√£o: Ra√ß√£o vs Peso")

        reg = analysis['regression']

        col1, col2, col3 = st.columns(3)

        with col1:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.metric("üìä Coeficiente Angular", f"{reg['slope']:.4f}")
            st.markdown('</div>', unsafe_allow_html=True)

        with col2:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.metric("üìà Intercepto", f"{reg['intercept']:.4f}")
            st.markdown('</div>', unsafe_allow_html=True)

        with col3:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.metric("üéØ R¬≤ (Ajuste)", f"{reg['r2']:.3f}")
            st.markdown('</div>', unsafe_allow_html=True)

        # Gr√°fico de regress√£o
        fig_reg = go.Figure()

        # Pontos observados
        fig_reg.add_trace(go.Scatter(
            x=reg['X'],
            y=reg['y'],
            mode='markers',
            name='Dados Observados',
            marker=dict(size=8, color='blue', opacity=0.6)
        ))

        # Linha de regress√£o
        fig_reg.add_trace(go.Scatter(
            x=reg['X'],
            y=reg['predictions'],
            mode='lines',
            name=f'Regress√£o (R¬≤ = {reg["r2"]:.3f})',
            line=dict(color='red', width=3)
        ))

        fig_reg.update_layout(
            title=f"Regress√£o Linear: Peso = {reg['slope']:.4f} √ó Ra√ß√£o + {reg['intercept']:.4f}",
            xaxis_title="Ra√ß√£o Consumida (kg)",
            yaxis_title="Peso M√©dio (kg)",
            template="plotly_white",
            height=500
        )

        st.plotly_chart(fig_reg, use_container_width=True)

        # Interpreta√ß√£o da regress√£o
        st.info(f"""
        **Interpreta√ß√£o da Regress√£o:**
        - Para cada 1 kg de ra√ß√£o adicional, o peso aumenta em m√©dia {reg['slope']:.4f} kg
        - O modelo explica {reg['r2'] * 100:.1f}% da varia√ß√£o no peso dos peixes
        - {"Modelo com bom ajuste" if reg['r2'] > 0.7 else "Modelo com ajuste moderado" if reg['r2'] > 0.5 else "Modelo com ajuste fraco"}
        """)

    # Estat√≠sticas detalhadas por vari√°vel
    st.subheader("üìã Estat√≠sticas Detalhadas")

    if 'peso_statistics' in analysis:
        peso_stats = analysis['peso_statistics']

        st.write("**üêü Estat√≠sticas do Peso dos Peixes:**")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.write(f"**M√©dia:** {peso_stats['mean']:.3f} kg")
            st.write(f"**Mediana:** {peso_stats['median']:.3f} kg")
            st.write(f"**Desvio Padr√£o:** {peso_stats['std']:.3f} kg")
            st.markdown('</div>', unsafe_allow_html=True)

        with col2:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.write(f"**M√≠nimo:** {peso_stats['min']:.3f} kg")
            st.write(f"**M√°ximo:** {peso_stats['max']:.3f} kg")
            st.write(f"**Amplitude:** {peso_stats['max'] - peso_stats['min']:.3f} kg")
            st.markdown('</div>', unsafe_allow_html=True)

        with col3:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.write(f"**Q1 (25%):** {peso_stats['q1']:.3f} kg")
            st.write(f"**Q3 (75%):** {peso_stats['q3']:.3f} kg")
            st.write(f"**IQR:** {peso_stats['iqr']:.3f} kg")
            st.markdown('</div>', unsafe_allow_html=True)

        with col4:
            st.markdown('<div class="stat-card">', unsafe_allow_html=True)
            st.write(f"**Assimetria:** {peso_stats['skewness']:.3f}")
            st.write(f"**Curtose:** {peso_stats['kurtosis']:.3f}")
            st.write(f"**N. Amostras:** {peso_stats['count']}")
            st.markdown('</div>', unsafe_allow_html=True)

        # Intervalo de confian√ßa
        st.write(f"""
        **Intervalo de Confian√ßa ({peso_stats['confidence_level']}%):** 
        [{peso_stats['ci_lower']:.3f}, {peso_stats['ci_upper']:.3f}] kg
        """)

    # An√°lise por tanque
    if 'tank_analysis' in analysis:
        st.subheader("üèä An√°lise Comparativa por Tanque")

        tank_stats = analysis['tank_analysis']

        # Criar DataFrame para compara√ß√£o
        tank_comparison = []
        for tanque, stats in tank_stats.items():
            tank_comparison.append({
                'Tanque': f'Tanque {tanque}',
                'Peso M√©dio (kg)': f"{stats['peso_medio']:.3f}",
                'Desvio Padr√£o': f"{stats['peso_std']:.3f}",
                'Efici√™ncia M√©dia': f"{stats['eficiencia_media']:.2f}",
                'TCA M√©dia': f"{stats['tca_media']:.2f}",
                'N¬∞ Registros': stats['n_registros']
            })

        tank_df = pd.DataFrame(tank_comparison)
        st.dataframe(tank_df, use_container_width=True, hide_index=True)

        # Gr√°fico comparativo
        fig_comparison = make_subplots(
            rows=1, cols=3,
            subplot_titles=("Peso M√©dio por Tanque", "Efici√™ncia por Tanque", "TCA por Tanque")
        )

        tanques = list(tank_stats.keys())
        pesos = [tank_stats[t]['peso_medio'] for t in tanques]
        eficiencias = [tank_stats[t]['eficiencia_media'] for t in tanques]
        tcas = [tank_stats[t]['tca_media'] for t in tanques]

        fig_comparison.add_trace(
            go.Bar(x=[f'T{t}' for t in tanques], y=pesos, name='Peso', marker_color='blue'),
            row=1, col=1
        )

        fig_comparison.add_trace(
            go.Bar(x=[f'T{t}' for t in tanques], y=eficiencias, name='Efici√™ncia', marker_color='green'),
            row=1, col=2
        )

        fig_comparison.add_trace(
            go.Bar(x=[f'T{t}' for t in tanques], y=tcas, name='TCA', marker_color='orange'),
            row=1, col=3
        )

        fig_comparison.update_layout(
            title="Compara√ß√£o de Performance entre Tanques",
            height=400,
            showlegend=False,
            template="plotly_white"
        )

        st.plotly_chart(fig_comparison, use_container_width=True)


def display_automated_reports(data, analysis):
    """Gera relat√≥rios automatizados"""

    st.subheader("üìã Relat√≥rios Automatizados")

    # Relat√≥rio Executivo
    st.subheader("üìä Relat√≥rio Executivo")

    # Resumo geral
    total_peixes = data['n_peixes'].sum()
    peso_medio_geral = data['peso_medio'].mean()
    total_racao = data['total_racao'].sum()
    eficiencia_geral = data['eficiencia_alimentar'].mean()

    st.markdown(f"""
    ### üìà **Resumo do Per√≠odo**

    **üêü Popula√ß√£o Total:** {total_peixes:,.0f} peixes  
    **‚öñÔ∏è Peso M√©dio Geral:** {peso_medio_geral:.3f} kg  
    **üçΩÔ∏è Ra√ß√£o Total Consumida:** {total_racao:.1f} kg  
    **‚ö° Efici√™ncia Alimentar M√©dia:** {eficiencia_geral:.2f}  

    ---
    """)

    # An√°lise de performance
    if 'tca_periodo' in data.columns:
        tca_media = data['tca_periodo'].mean()

        if tca_media < 1.5:
            performance = "üü¢ **EXCELENTE**"
            recomendacao = "Manter as pr√°ticas atuais de manejo."
        elif tca_media < 2.0:
            performance = "üîµ **BOA**"
            recomendacao = "Otimizar hor√°rios de alimenta√ß√£o e qualidade da ra√ß√£o."
        elif tca_media < 2.5:
            performance = "üü° **REGULAR**"
            recomendacao = "Revisar estrat√©gia alimentar e monitorar qualidade da √°gua."
        else:
            performance = "üî¥ **BAIXA**"
            recomendacao = "Interven√ß√£o necess√°ria: revisar ra√ß√£o, densidade e ambiente."

        st.markdown(f"""
        ### üéØ **Avalia√ß√£o de Performance**

        **Taxa de Convers√£o Alimentar:** {tca_media:.2f}  
        **Status:** {performance}  
        **Recomenda√ß√£o:** {recomendacao}

        ---
        """)

    # Alertas e recomenda√ß√µes
    st.subheader("üö® Alertas e Recomenda√ß√µes")

    alertas = []

    # Verificar efici√™ncia baixa
    tanques_baixa_eff = data[data['eficiencia_alimentar'] < 1.0]['tanque'].unique()
    if len(tanques_baixa_eff) > 0:
        alertas.append(f"‚ö†Ô∏è **Efici√™ncia baixa** nos tanques: {', '.join(map(str, tanques_baixa_eff))}")

    # Verificar variabilidade alta
    cv_peso = (data['peso_medio'].std() / data['peso_medio'].mean()) * 100
    if cv_peso > 20:
        alertas.append(f"üìä **Alta variabilidade** no peso (CV = {cv_peso:.1f}%)")

    # Verificar crescimento
    if 'crescimento_diario' in data.columns:
        crescimento_negativo = data[data['crescimento_diario'] < 0]
        if len(crescimento_negativo) > 0:
            alertas.append("üìâ **Per√≠odos de crescimento negativo** detectados")

    if alertas:
        for alerta in alertas:
            st.warning(alerta)
    else:
        st.success("‚úÖ **Nenhum alerta cr√≠tico identificado**")

    # Tend√™ncias identificadas
    st.subheader("üìà Tend√™ncias Identificadas")

    if len(data) > 1:
        # Tend√™ncia de peso
        peso_inicial = data['peso_medio'].iloc[0]
        peso_final = data['peso_medio'].iloc[-1]
        variacao_peso = ((peso_final - peso_inicial) / peso_inicial) * 100

        if variacao_peso > 5:
            trend_peso = f"üìà **Crescimento positivo** de {variacao_peso:.1f}%"
        elif variacao_peso < -5:
            trend_peso = f"üìâ **Decl√≠nio** de {abs(variacao_peso):.1f}%"
        else:
            trend_peso = f"‚û°Ô∏è **Estabilidade** (varia√ß√£o de {variacao_peso:.1f}%)"

        st.write(trend_peso)

        # Tend√™ncia de efici√™ncia
        if 'eficiencia_alimentar' in data.columns:
            eff_inicial = data['eficiencia_alimentar'].iloc[0]
            eff_final = data['eficiencia_alimentar'].iloc[-1]

            if eff_final > eff_inicial * 1.1:
                trend_eff = "üìà **Melhoria na efici√™ncia alimentar**"
            elif eff_final < eff_inicial * 0.9:
                trend_eff = "üìâ **Decl√≠nio na efici√™ncia alimentar**"
            else:
                trend_eff = "‚û°Ô∏è **Efici√™ncia est√°vel**"

            st.write(trend_eff)

    # Recomenda√ß√µes espec√≠ficas
    st.subheader("üí° Recomenda√ß√µes Espec√≠ficas")

    recomendacoes = [
        "üîÑ **Monitoramento cont√≠nuo** da TCA para otimiza√ß√£o",
        "üìä **An√°lise semanal** dos indicadores de performance",
        "üå°Ô∏è **Controle rigoroso** dos par√¢metros ambientais",
        "üìà **Ajuste da estrat√©gia alimentar** baseado nos dados"
    ]

    for rec in recomendacoes:
        st.write(rec)


def display_data_preview():
    """Mostra preview dos dados carregados do Google Sheets"""
    st.subheader("üìä Preview dos Dados do Google Sheets")

    sheets_data = st.session_state.sheets_data

    tab1, tab2 = st.tabs(["üêü Dados das Til√°pias", "üçΩÔ∏è Dados de Ra√ß√£o"])

    with tab1:
        if 'tilapias' in sheets_data:
            tilapias_df = sheets_data['tilapias']
            st.write(f"**Total de registros:** {len(tilapias_df)}")
            st.write(f"**Colunas:** {list(tilapias_df.columns)}")

            # Estat√≠sticas b√°sicas
            if 'data' in tilapias_df.columns:
                try:
                    tilapias_df['data'] = pd.to_datetime(tilapias_df['data'], errors='coerce')
                    valid_dates = tilapias_df['data'].dropna()
                    if not valid_dates.empty:
                        date_range = f"{valid_dates.min().strftime('%d/%m/%Y')} a {valid_dates.max().strftime('%d/%m/%Y')}"
                        st.write(f"**Per√≠odo:** {date_range}")
                except:
                    st.write("**Per√≠odo:** N√£o foi poss√≠vel determinar")

            # Mostrar amostra
            st.dataframe(tilapias_df.head(10), use_container_width=True)

            # Estat√≠sticas das colunas num√©ricas
            numeric_cols = tilapias_df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                st.write("**Estat√≠sticas das colunas num√©ricas:**")
                st.dataframe(tilapias_df[numeric_cols].describe(), use_container_width=True)
        else:
            st.error("‚ùå Dados das til√°pias n√£o carregados")

    with tab2:
        if 'racao' in sheets_data:
            racao_df = sheets_data['racao']
            st.write(f"**Total de registros:** {len(racao_df)}")
            st.write(f"**Colunas:** {list(racao_df.columns)}")

            # Estat√≠sticas b√°sicas
            if 'data' in racao_df.columns:
                try:
                    racao_df['data'] = pd.to_datetime(racao_df['data'], errors='coerce')
                    valid_dates = racao_df['data'].dropna()
                    if not valid_dates.empty:
                        date_range = f"{valid_dates.min().strftime('%d/%m/%Y')} a {valid_dates.max().strftime('%d/%m/%Y')}"
                        st.write(f"**Per√≠odo:** {date_range}")
                except:
                    st.write("**Per√≠odo:** N√£o foi poss√≠vel determinar")

            # Mostrar amostra
            st.dataframe(racao_df.head(10), use_container_width=True)

            # Estat√≠sticas das colunas num√©ricas
            numeric_cols = racao_df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                st.write("**Estat√≠sticas das colunas num√©ricas:**")
                st.dataframe(racao_df[numeric_cols].describe(), use_container_width=True)
        else:
            st.error("‚ùå Dados de ra√ß√£o n√£o carregados")


def display_welcome_advanced():
    """Tela de boas-vindas avan√ßada"""
    st.markdown("""
    <div style="text-align: center; padding: 3rem;">
        <h2 style="color: #1e3a8a;">üîó Sistema Avan√ßado de Aquicultura</h2>
        <p style="font-size: 1.1rem; color: #64748b;">
            Conectado ao Google Sheets com an√°lises estat√≠sticas avan√ßadas
        </p>
    </div>
    """, unsafe_allow_html=True)

    col1, col2, col3 = st.columns([1, 2, 1])

    with col2:
        st.markdown("""
        ### üöÄ Funcionalidades Avan√ßadas

        ####    **Filtros Inteligentes**
        - **Per√≠odo personaliz√°vel**: Formato dd/mm/aa
        - **Sele√ß√£o de tanques**: Um, v√°rios ou todos
        - **N√≠vel de confian√ßa**: 90%, 95% ou 99%

        #### üìä **An√°lises Estat√≠sticas**
        - **Taxa de Convers√£o Alimentar (TCA)**
        - **Curva de Gauss** do peso dos peixes
        - **Regress√µes e correla√ß√µes** avan√ßadas
        - **An√°lise temporal** peso vs ra√ß√£o

        #### üìà **Gr√°ficos Sofisticados**
        - **Distribui√ß√µes** e tend√™ncias
        - **Correla√ß√µes** multivariadas
        - **Evolu√ß√£o temporal** por tanque
        - **Dashboards** interativos

        #### üìã **Relat√≥rios Automatizados**
        - **Exporta√ß√£o PDF** com gr√°ficos
        - **Dashboards** executivos
        - **An√°lises** detalhadas por tanque

        #### ü§ñ **Assistente de IA**
        - **Prof. Tilap-IA** dispon√≠vel no √≠cone flutuante
        - **Interpreta√ß√£o inteligente** dos dados
        - **Recomenda√ß√µes personalizadas**
        - **Chat especializado** em aquicultura
        """)

        st.info("""
        üí° **Como usar:**
        1. Clique em "Carregar/Atualizar Dados"
        2. Configure os filtros desejados
        3. Clique em "Processar An√°lise Completa"
        4. Explore as abas de an√°lises
        5. Use o Prof. Tilap-IA para insights adicionais
        """)

# CONTINUA NA PARTE 4
# CONTINUA√á√ÉO DA PARTE 3 - Exporta√ß√£o e Fun√ß√µes Finais

def display_advanced_export(data, analysis):
    """Exporta√ß√£o avan√ßada com m√∫ltiplos formatos"""

    st.subheader("üíæ Exporta√ß√£o Avan√ßada")

    col1, col2 = st.columns(2)

    with col1:
        st.subheader("üìÑ Op√ß√µes de Exporta√ß√£o")

        export_format = st.selectbox(
            "üìÅ Formato:",
            ["CSV", "Excel Completo", "PDF Relat√≥rio", "JSON Dados"],
            key="selectbox_formato_export_main"
        )

        include_charts = st.checkbox("üìä Incluir gr√°ficos", True, key="checkbox_graficos_main")
        include_statistics = st.checkbox("üìà Incluir estat√≠sticas", True, key="checkbox_estatisticas_main")
        include_analysis = st.checkbox("üî¨ Incluir an√°lises", True, key="checkbox_analises_main")

    with col2:
        st.subheader("‚öôÔ∏è Configura√ß√µes")

        date_format = st.selectbox(
            "üìÖ Formato de data:",
            ["DD/MM/YYYY", "YYYY-MM-DD", "MM/DD/YYYY"],
            key="selectbox_formato_data_main"
        )

        decimal_places = st.slider("üî¢ Casas decimais:", 1, 4, 3, key="slider_decimais_main")

        include_metadata = st.checkbox("üìù Incluir metadados", True, key="checkbox_metadata_main")

    # Bot√µes de exporta√ß√£o
    st.subheader("üì• Download")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        if st.button("üìÑ Exportar CSV", use_container_width=True, key="btn_export_csv_main"):
            csv_data = prepare_csv_export(data, decimal_places, date_format)

            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"aquicultura_completo_{timestamp}.csv"

            st.download_button(
                "üì• Download CSV",
                csv_data,
                filename,
                "text/csv",
                key="download_csv_main"
            )

    with col2:
        if st.button("üìä Exportar Excel", use_container_width=True, key="btn_export_excel_main"):
            excel_data = prepare_excel_export(
                data, analysis, include_charts,
                include_statistics, decimal_places
            )

            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"relatorio_aquicultura_{timestamp}.xlsx"

            st.download_button(
                "üì• Download Excel",
                excel_data,
                filename,
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key="download_excel_main"
            )

    with col3:
        if st.button("üìã Exportar PDF", use_container_width=True, key="btn_export_pdf_main"):
            pdf_data = prepare_pdf_export(data, analysis, include_charts)

            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"relatorio_executivo_{timestamp}.pdf"

            st.download_button(
                "üì• Download PDF",
                pdf_data,
                filename,
                "application/pdf",
                key="download_pdf_main"
            )

    with col4:
        if st.button("üîó Exportar JSON", use_container_width=True, key="btn_export_json_main"):
            json_data = prepare_json_export(data, analysis, include_metadata)

            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"dados_aquicultura_{timestamp}.json"

            st.download_button(
                "üì• Download JSON",
                json_data,
                filename,
                "application/json",
                key="download_json_main"
            )

    # Preview dos dados
    st.subheader("üëÄ Preview dos Dados")

    preview_data = data.copy()
    numeric_cols = preview_data.select_dtypes(include=[np.number]).columns
    preview_data[numeric_cols] = preview_data[numeric_cols].round(decimal_places)

    if date_format == "DD/MM/YYYY":
        preview_data['data'] = preview_data['data'].dt.strftime('%d/%m/%Y')
    elif date_format == "MM/DD/YYYY":
        preview_data['data'] = preview_data['data'].dt.strftime('%m/%d/%Y')
    else:
        preview_data['data'] = preview_data['data'].dt.strftime('%Y-%m-%d')

    st.dataframe(preview_data.head(10), use_container_width=True)

    # Informa√ß√µes do dataset
    st.subheader("‚ÑπÔ∏è Informa√ß√µes do Dataset")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric("üìä Total de Registros", len(data))

    with col2:
        st.metric("üìÖ Per√≠odo", f"{len(data['data'].unique())} dias")

    with col3:
        st.metric("üèä Tanques", len(data['tanque'].unique()))


def prepare_csv_export(data, decimal_places, date_format):
    """Prepara dados para exporta√ß√£o CSV"""

    export_data = data.copy()

    # Formatar data
    if date_format == "DD/MM/YYYY":
        export_data['data'] = export_data['data'].dt.strftime('%d/%m/%Y')
    elif date_format == "MM/DD/YYYY":
        export_data['data'] = export_data['data'].dt.strftime('%m/%d/%Y')
    else:
        export_data['data'] = export_data['data'].dt.strftime('%Y-%m-%d')

    # Arredondar valores num√©ricos
    numeric_cols = export_data.select_dtypes(include=[np.number]).columns
    export_data[numeric_cols] = export_data[numeric_cols].round(decimal_places)

    return export_data.to_csv(index=False)


def prepare_excel_export(data, analysis, include_charts, include_statistics, decimal_places):
    """Prepara dados para exporta√ß√£o Excel"""

    output = io.BytesIO()

    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        # Dados principais
        main_data = data.copy()
        numeric_cols = main_data.select_dtypes(include=[np.number]).columns
        main_data[numeric_cols] = main_data[numeric_cols].round(decimal_places)
        main_data.to_excel(writer, sheet_name='Dados Principais', index=False)

        # Estat√≠sticas
        if include_statistics and analysis:
            if 'peso_statistics' in analysis:
                peso_stats = pd.DataFrame([analysis['peso_statistics']])
                peso_stats.to_excel(writer, sheet_name='Estat√≠sticas Peso', index=False)

            if 'tank_analysis' in analysis:
                tank_stats = pd.DataFrame(analysis['tank_analysis']).T
                tank_stats.to_excel(writer, sheet_name='An√°lise por Tanque')

        # Correla√ß√µes
        if 'correlations' in analysis:
            analysis['correlations'].to_excel(writer, sheet_name='Correla√ß√µes')

        # Resumo por tanque
        if 'tanque' in data.columns:
            resumo_tanque = data.groupby('tanque').agg({
                'peso_medio': ['mean', 'std', 'min', 'max'],
                'total_racao': ['sum', 'mean'],
                'eficiencia_alimentar': ['mean', 'std'],
                'n_peixes': 'mean'
            }).round(decimal_places)

            resumo_tanque.to_excel(writer, sheet_name='Resumo por Tanque')

    return output.getvalue()


def prepare_pdf_export(data, analysis, include_charts):
    """Prepara relat√≥rio PDF"""

    try:
        from reportlab.lib.pagesizes import letter, A4
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.lib import colors
        PDF_AVAILABLE = True
    except ImportError:
        PDF_AVAILABLE = False

    if not PDF_AVAILABLE:
        st.warning("‚ö†Ô∏è Exporta√ß√£o PDF n√£o dispon√≠vel. Biblioteca ReportLab n√£o instalada.")
        return b""

    try:
        # Criar buffer para PDF
        buffer = io.BytesIO()

        # Criar documento PDF
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []

        # T√≠tulo
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            spaceAfter=30,
            alignment=1  # Center
        )

        story.append(Paragraph("Relat√≥rio de Aquicultura Analytics", title_style))
        story.append(Spacer(1, 20))

        # Data do relat√≥rio
        story.append(Paragraph(f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}", styles['Normal']))
        story.append(Spacer(1, 20))

        # Resumo executivo
        story.append(Paragraph("Resumo Executivo", styles['Heading2']))

        peso_medio = data['peso_medio'].mean()
        total_racao = data['total_racao'].sum()
        eficiencia = data['eficiencia_alimentar'].mean()

        resumo_text = f"""
        ‚Ä¢ Peso m√©dio dos peixes: {peso_medio:.3f} kg<br/>
        ‚Ä¢ Total de ra√ß√£o consumida: {total_racao:.1f} kg<br/>
        ‚Ä¢ Efici√™ncia alimentar m√©dia: {eficiencia:.2f}<br/>
        ‚Ä¢ Per√≠odo analisado: {len(data)} registros<br/>
        ‚Ä¢ Tanques monitorados: {len(data['tanque'].unique())}
        """

        story.append(Paragraph(resumo_text, styles['Normal']))
        story.append(Spacer(1, 20))

        # Estat√≠sticas por tanque
        if len(data['tanque'].unique()) > 1:
            story.append(Paragraph("An√°lise por Tanque", styles['Heading2']))

            # Criar tabela
            tank_data = []
            tank_data.append(['Tanque', 'Peso M√©dio (kg)', 'Efici√™ncia', 'Ra√ß√£o Total (kg)'])

            for tanque in sorted(data['tanque'].unique()):
                tank_subset = data[data['tanque'] == tanque]
                peso_tanque = tank_subset['peso_medio'].mean()
                eff_tanque = tank_subset['eficiencia_alimentar'].mean()
                racao_tanque = tank_subset['total_racao'].sum()

                tank_data.append([
                    f'Tanque {tanque}',
                    f'{peso_tanque:.3f}',
                    f'{eff_tanque:.2f}',
                    f'{racao_tanque:.1f}'
                ])

            table = Table(tank_data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))

            story.append(table)
            story.append(Spacer(1, 20))

        # Recomenda√ß√µes
        story.append(Paragraph("Recomenda√ß√µes", styles['Heading2']))

        if 'tca_periodo' in data.columns:
            tca_media = data['tca_periodo'].mean()

            if tca_media < 1.5:
                recomendacao = "Excelente performance. Manter pr√°ticas atuais."
            elif tca_media < 2.0:
                recomendacao = "Boa performance. Considerar otimiza√ß√µes pontuais."
            else:
                recomendacao = "Performance pode ser melhorada. Revisar estrat√©gia alimentar."

            story.append(Paragraph(f"TCA M√©dia: {tca_media:.2f} - {recomendacao}", styles['Normal']))

        story.append(Paragraph("‚Ä¢ Monitoramento cont√≠nuo dos indicadores", styles['Normal']))
        story.append(Paragraph("‚Ä¢ An√°lise semanal de tend√™ncias", styles['Normal']))
        story.append(Paragraph("‚Ä¢ Controle de par√¢metros ambientais", styles['Normal']))

        # Construir PDF
        doc.build(story)

        return buffer.getvalue()

    except Exception as e:
        st.error(f"‚ùå Erro ao gerar PDF: {e}")
        return b""


def prepare_json_export(data, analysis, include_metadata):
    """Prepara dados para exporta√ß√£o JSON"""

    # Converter dados para formato serializ√°vel
    data_dict = data.copy()

    # Converter datetime para string
    if 'data' in data_dict.columns:
        data_dict['data'] = data_dict['data'].dt.strftime('%Y-%m-%d')

    # Converter numpy types para tipos Python nativos
    for col in data_dict.select_dtypes(include=[np.number]).columns:
        data_dict[col] = data_dict[col].astype(float)

    export_dict = {
        "dados": data_dict.to_dict('records'),
        "estatisticas": analysis if analysis else {},
        "resumo": {
            "total_registros": int(len(data)),
            "periodo_dias": int(len(data['data'].unique())),
            "tanques": int(len(data['tanque'].unique())),
            "peso_medio_geral": float(data['peso_medio'].mean()),
            "total_racao": float(data['total_racao'].sum()),
            "eficiencia_media": float(data['eficiencia_alimentar'].mean())
        }
    }

    if include_metadata:
        export_dict["metadata"] = {
            "data_exportacao": datetime.now().isoformat(),
            "versao": "1.0",
            "fonte": "Aquicultura Analytics Pro",
            "colunas": list(data.columns),
            "tipos_dados": {col: str(dtype) for col, dtype in data.dtypes.items()}
        }

    import json
    return json.dumps(export_dict, indent=2, ensure_ascii=False)


if __name__ == "__main__":
    main()